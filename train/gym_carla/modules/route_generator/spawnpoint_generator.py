"""
This script is responsible for generating start waypoints
for a intersection scenario.

Modified based on junction_route_generator.py

"""

from gym_carla.config.carla_config import version_config

carla_version = version_config['carla_version']
root_path = version_config['root_path']

# ==================================================
# import carla module
import glob
import os
import sys

carla_root = os.path.join(root_path, 'CARLA_' + carla_version)
carla_path = os.path.join(carla_root, 'PythonAPI')
sys.path.append(carla_path)
sys.path.append(os.path.join(carla_root, 'PythonAPI/carla'))
sys.path.append(os.path.join(carla_root, 'PythonAPI/carla/agents'))

try:
    sys.path.append(glob.glob(carla_path + '/carla/dist/carla-*%d.%d-%s.egg' % (
        sys.version_info.major,
        sys.version_info.minor,
        'win-amd64' if os.name == 'nt' else 'linux-x86_64'))[0])
except IndexError:
    pass

import carla

import numpy as np

# original version
from gym_carla.envs.BasicEnv import BasicEnv
from gym_carla.modules.carla_module import CarlaModule
from gym_carla.util_development.util_visualization import draw_waypoint

# for debug
default_junction_center = carla.Location(x=-1.32, y=132.69, z=0.00)

# carla colors
red = carla.Color(r=255, g=0, b=0)
green = carla.Color(r=0, g=255, b=0)
blue = carla.Color(r=0, g=0, b=255)
yellow = carla.Color(r=255, g=255, b=0)
magenta = carla.Color(r=255, g=0, b=255)
yan = carla.Color(r=0, g=255, b=255)
orange = carla.Color(r=255, g=162, b=0)
white = carla.Color(r=255, g=255, b=255)


class SpawnPointGenerator(CarlaModule):
    """
    This class is responsible for generating spawn point
    of each direction around an intersection.
    """

    def __init__(self, carla_api, junction=None, distance=10):

        super(SpawnPointGenerator, self).__init__(carla_api)

        # spawn points
        # this waypoint is generated by generate_route, with a selection of route
        self.spawn_waypoint = None  # carla.Waypoint

        # distance from start waypoint to junction bbox
        self.distance = distance

        # assign junction
        if junction:
            self.junction = junction
        else:
            self.junction = self.get_junction_by_location(default_junction_center)

    def get_junction_by_location(self, center_location):
        """
        Get a junction instance by a location contained in the junction.

        For the junction of which center coordinate is known.

        param center_location: carla.Location of the junction center
        """
        wp = self.map.get_waypoint(location=center_location,
                                   project_to_road=False,  # not in the center of lane(road)
                                   lane_type=carla.LaneType.Driving)
        junction = wp.get_junction()

        self.junction = junction

        return junction

    def set_distance(self, distance: float):
        """
        Set route distance manually.
        """
        self.distance = distance

    def get_start_waypoints(self):
        """
        Get available start waypoints of a junction.

        Assuming a 4-direction junction.
        """
        bbox = self.junction.bounding_box
        location = bbox.location
        extent = bbox.extent
        # todo if rotation on junction
        rotation = bbox.rotation  # original rotation of the b box

        # plot the junction
        # transform of the junction center
        transform = carla.Transform(location, rotation)
        # todo use plot coord frame to plot
        draw_waypoint(self.world, transform)
        # bounding box
        self.debug_helper.draw_box(box=bbox,
                                   rotation=rotation,
                                   thickness=0.5,
                                   color=red,
                                   life_time=-1.0)

        lane_width = self.map.get_waypoint(location).lane_width

        # start location
        # sequence as [+x -x +y -y] according to local rotation
        x_shift = -1. * lane_width
        x_slack = 0.75  # slack to fit different junction
        x_start = np.array([
            location.x + (extent.x + self.distance),
            location.x - (extent.x + self.distance),
            location.x + x_slack * lane_width + x_shift,
            location.x - x_slack * lane_width + x_shift,
        ])

        y_shift = 0. * lane_width
        y_slack = 0.75
        y_start = np.array([
            location.y - y_slack * lane_width + y_shift,
            location.y + y_slack * lane_width + y_shift,
            location.y + (extent.y + self.distance),
            location.y - (extent.y + self.distance),
        ])

        # plot the fixed coord center, for locate correct lane
        loc = carla.Location(x=location.x + x_shift,
                             y=location.y
                             )

        trans = carla.Transform(loc, rotation)
        draw_waypoint(self.world, trans, color=(orange, orange))

        start_waypoints = []
        direction_ids = ['+x', '-x', '+y', '-y']
        for i in range(4):
            start_location = carla.Location(x=x_start[i], y=y_start[i], z=0)
            start_waypoint = self.map.get_waypoint(location=start_location,
                                                   project_to_road=True,  # not in the center of lane(road)
                                                   lane_type=carla.LaneType.Driving)

            # todo automatically get waypoints of different lane on same direction
            # lane_id = start_waypoint.lane_id

            # default order of start_waypoints list is: [+x, -x, +y, -y]
            start_waypoints.append(start_waypoint)
            draw_waypoint(self.world, start_waypoint)
            print('start waypoint on ', direction_ids[i], ' direction: [',
                  start_waypoint.transform.location.x,
                  start_waypoint.transform.location.y,
                  start_waypoint.transform.location.z,
                  ']',
                  )

        # todo merge this method with route generator
        # another spawn point on -y direction start waypoint
        loc = start_waypoints[3].transform.location
        loc.x = loc.x - lane_width
        negative_y_waypoint2 = self.map.get_waypoint(location=loc,
                                                     project_to_road=True,  # not in the center of lane(road)
                                                     lane_type=carla.LaneType.Driving)

        draw_waypoint(self.world, negative_y_waypoint2, (yan, yan))

        return start_waypoints, negative_y_waypoint2


def test():

    env = BasicEnv()
    env.set_world(sync_mode=False)
    env.set_spectator_overhead(default_junction_center, yaw=-90, h=70)
    # env.world.tick()

    carla_api = env.get_env_api()
    rou_gen = SpawnPointGenerator(carla_api)

    # # generate waypoints of different distance
    # for i in range(4):  # 20:50 m
    #     distance = 20 + 10 * i
    #     rou_gen.set_distance(distance)
    #     waypoints, y_wp = rou_gen.get_start_waypoints()
    #     print('distance: ', distance)

    distance = 40
    rou_gen.set_distance(distance)
    waypoints, y_wp = rou_gen.get_start_waypoints()
    print('distance: ', distance)

    print('done')


if __name__ == '__main__':

    test()
